ЛЗ 6. Решение задач по теме "Ссылки"
Выполнил студент группы П1-17 Саполетова Анастасия

1) Упражнение 2.24. Какие из следующих определений (если они есть) недопустимы? Почему? Как их исправить?
		(a) int ival = 1.01; - допустимо,но сотая часть отрежется. Лучше использовать double
		(b) int &rvall = 1.01; - не допустимо, ссылка может ссылаться только на переменную
		(с) int &rval2 = ival; - допустимо
		(d) const int &rval3 = 1; - допустимо


2) Упражнение 2.25. Какие из следующих присвоений (если они есть) являются недопустимыми
(с учетом предыдущих определений)? Если таковые есть, объясните, почему.
		(а) rva12 = 3.14159;- недопустимо, потому что переменная не была объявлена
		(b) rva12 = rva13; - недопустимо, потому что переменная не была объявлена
		(с) ival = rval3; - допустимо
		(d) rval3 = ival; - недопустимо, потому что не можем изменить значение const указателя


3) Упражнение 2.26. В чем разница между определениями (а) и присвоениями (Ь)?
Какие из них (если есть) недопустимы?
		(a)	int ival = 0;		(b) ival = ri; - допустимы оба варианта
			const int &ri =0;	ri = ival;


4) Что отобразит на экране следующий код?
		int i, &ri = i; i = 5; ri = 10;
		std::cout << i << " " << ri << std::endl;
		
		Ответ: 10 10.



5) Упражнение 4.15. Укажите принципиальные различия между указателями и ссылками.

		1.Ссылка не может быть неинициализированной.
		2.У ссылки нет нулевого значения.
		3.Ссылку нельзя переинициализировать.
		4.Нельзя получить адрес ссылки или ссылку на ссылку.
		5.Нельзя создавать массивы ссылок.
		6.Для ссылок нет арифметики.



6) Упражнение 7.7. Объясните различие между параметрами в следующих двух объявлениях.
		void f(Т);- передаем объект, и становится это локальной переменной
		void f(Т&); - передаем ссылку

		
7) Упражнение 7.8. Приведите пример случая, когда параметр должен быть ссылочным.

#include <iostream>  
void func(int &a)
{
  a = 5
}
int main()
{
  int a;
  func(a);
 std::cout << a;
}
Приведите пример случая, когда параметр не должен быть ссылочным.

unsigned gcd(unsigned a, unsigned b)
{
    return b == 0 ? a : gcd(b, a % b); 
}



8) Упражнение 7.10. Следующая функция хоть и вполне допустима, но менее полезна,
чем могла бы быть. Выявите и устраните ограничения.
bool test(string& s) { return s.empty(); } Написать main для аргументации своего решения

#include <iostream>
using namespace std;
bool test(string& s) 
{ 
	return s.empty(); 
}
int main()
{
	cout << test("Hello, world!"); - выдаст ошибку, потому что string& s нужно сделать константным
}


#include <iostream>
using namespace std;
bool test(const string& s) 
{ 
	return s.empty(); 
}
int main()
{
	cout << test("Hello, world!"); - ошибки не будет
}



9) Упражнение 7.11. Когда ссылочные параметры должны быть константными? 
Какие проблемы могут возникнуть, если параметр является обычной ссылкой, а какие — если он является константной ссылкой?

Ссылки в C++ используются не только для передачи изменяемых параметров в функции, но и для передачи больших параметров, 
копировать которые дорого. 
Если параметр является обычной ссылкой, то возникает проблема, что случайно можно изменить значение по этой ссылке на другое.
Если параметр является константной ссылкой, то мы не сможем его изменить.