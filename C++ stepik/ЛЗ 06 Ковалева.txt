[1] Упражнения раздела 2.5
1) Упражнение 2.24. Какие из следующих определений (если они есть) недопустимы? Почему? Как их исправить?
(a)	int ival = 1.01;
(b) int &rvall = 1.01;
(с)	int &rval2 = ival;
(d) const int &rval3 = 1;

Ответ: b. Данную запись можно исправить так : int rvall = 1.01; int *p = &rvall; 

2) Упражнение 2.25. Какие из следующих присвоений (если они есть) являются недопустимыми 
(с учетом предыдущих определений)? Если таковые есть, объясните, почему.
(а)	rva12 = 3.14159;
(b) rva12 = rva13;
(с)	ival = rval3;
(d) rval3 = ival;

Ответ: d. Потому что переменная rval3 - константа.

3) Упражнение 2.26. В чем разница между определениями (а) и присвоениями (Ь)? 
Какие из них (если есть) недопустимы?
(a)	int ival = 0;	(b) ival = ri;
const int &ri =0;	ri = ival;

Ответ: В варианте b переменной ri не присвоено никакое значение, если бы оно попало в какую-то операцию, 
в ответе мы бы увидели компьютерный мусор. И если переменная ival уже равна переменной ri, то действие
ri = ival не имеет смысла.

4) Упражнение 2.27. Что отобразит на экране следующий код?
int i, &ri = i; i = 5; ri = 10;
std::cout << i << " " << ri << std::endl;

Ответ: 10 10

[1] Упражнения раздела 4.2.3
5) Упражнение 4.15. Укажите принципиальные различия между указателями и ссылками.

Ответ: Ссылка не может быть неинициализированной
	Ссылка не имеет нулевого значения (будет ошибка)
	Ссылку нельзя переинициализировать
	Нельзя получить адрес ссылки или ссылку на ссылку
	Нельзя создавать массивы ссылок
	Для ссылок нет арифметики

[1] Упражнения раздела 7.2.2
6) Упражнение 7.7. Объясните различие между параметрами в следующих двух объявлениях.
void f(Т);
void f(Т&);

Ответ: в записи void f(Т); локальный параметр, а в void f(Т&); - глобальный.

7) Упражнение 7.8. Приведите пример случая, когда параметр должен быть ссылочным.
Приведите пример случая, когда параметр не должен быть ссылочным.

Ответ: Парамент должен быть ссылочным если во время выполнения программы значение будет изменяться
Например : int f(int &x, int &y) 
Параметр не должен быть ссылочным, если нет необходимости менять его значение.

8) Упражнение 7.10. Следующая функция хоть и вполне допустима, но менее полезна,
чем могла бы быть. Выявите и устраните ограничения.
bool test(string& s) { return s.empty(); } Написать main для аргументации своего решения

Ответ: функция вида bool test(string& s) { return s.empty(); } не сможет работать с rvalue.
Для исправления ошибки немного изменим функцию : bool test(const string& s) { return s.empty(); }

#include <iostream>
#include <string>
using namespace std;

bool test1(string& s) { return s.empty(); }
bool test2(const string& s) { return s.empty(); }

int main()
{
    string s;
    cin >> s;
    cout << test1("s"); //ошибка
    cout << test2("s"); //все работает
}


9) Упражнение 7.11. Когда ссылочные параметры должны быть константными? 
Какие проблемы могут возникнуть, если параметр является обычной ссылкой, 
а какие — если он является константной ссылкой?

Ответ: Если в параметре будет константная ссылка, то мы не сможем ее изменить, если это потребуется. 
Но будет отсутствовать привязка типов объекта. Тк ссылку можно связать с переменными других типов.
Если наоборот, параметр будет обычной ссылкой, то мы сможем изменить значение. Это как хорошо так и плохо,
тк значение может измениться случайно и результат изменится.