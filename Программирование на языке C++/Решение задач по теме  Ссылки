МДК.01.02 "Прикладное программирование"
ЛЗ 6. Решение задач по теме "Ссылки"
Составитель: Гусятинер Л.Б., 25.04.2020, МГОТУ ККМТ, П1-17, П2-17
Решил: Юшаков Н. Р., группа П1-17

[1] Упражнения раздела 2.5
1) Упражнение 2.24. Какие из следующих определений (если они есть) недопустимы? Почему? Как их исправить?
(a)	int ival = 1.01;
(b) int &rvall = 1.01;
(с)	int &rval2 = ival;
(d) const int &rval3 = 1;

Ответ: b, потому что не const ссылки не могут быть инициализированы rvalue выражением.
Исправить это можно объявив ссылку rvall как const int& ravall. 
(Из книги Ббёрна Строуструпа)
Инициализатор для const T& не обязан быть lvalue и даже иметь тип T. В таких случаях:
1) если необходимо, осуществляется неявное преобразование к типу T;
2) результирующее значение помещается во временную переменную типа T;
3) временная переменная используется как значение инициализатора.

2) Упражнение 2.25. Какие из следующих присвоений (если они есть) являются недопустимыми 
(с учетом предыдущих определений)? Если таковые есть, объясните, почему.
(а)	rva12 = 3.14159;
(b) rva12 = rva13;
(с)	ival = rval3;
(d) rval3 = ival;

Ответ: d, потму что мы не можем изменить значение константного указателя.

3) Упражнение 2.26. В чем разница между определениями (а) и присвоениями (Ь)? 
Какие из них (если есть) недопустимы?
(a)	int ival = 0;	(b) ival = ri;
const int &ri =0;	ri = ival;

Ответ: определение - выдление области в памяти для хранения данных переменной определенного типа.
присвоние - запись в выделенную область памяти какого-то значения.
В b присвоение ri = ival недопустипо т.к. ri это константная ссылка и нельзя изменить ее значение.

4) Упражнение 2.27. Что отобразит на экране следующий код?
int i, &ri = i; i = 5; ri = 10;
std::cout << i << " " << ri << std::endl;

Ответ: 10 10

[1] Упражнения раздела 4.2.3
5) Упражнение 4.15. Укажите принципиальные различия между указателями и ссылками.

Ответ:  1) нельзя объявить массив ссылок
	2) у ссылок нет адреса
	3) у ссылок нет арифметике, а у указателей есть
	4) ссылки, в отличии от указателей, не моут быть неинициализированными
	5) ссылки не могут быть изменены после инициализации

[1] Упражнения раздела 7.2.2
6) Упражнение 7.7. Объясните различие между параметрами в следующих двух объявлениях.
void f(Т);
void f(Т&);

Ответ: 1 параметр будет локальным(создастся копия того что мы передали в функцию, которая будет уничтожена сразу после выхода из функции), 
2 параметр будет глобальным(мы сможем изменять то что мы передали в фунцию и эти изменения сохрансятся после выхода из функции).

7) Упражнение 7.8. Приведите пример случая, когда параметр должен быть ссылочным.
Приведите пример случая, когда параметр не должен быть ссылочным.

Ответ: параметр должен быть ссылочным если нам нужно будет изменять его значение, например для обмена значений переменных:
void swap(int & a, int & b) {
	int temp = a;
	a = b;
	b = temp;
}

параметр не должен быть ссылочным если нам нужно только его значение и мы не планирем менять его, например для старого и нового
размера динамического массива в функции изменения размера дин. массива:
char *resize(const char *str, unsigned size, unsigned new_size)
{
    char *new_str = new char[new_size];
    for (int i = 0; i < ((size > new_size) ? new_size : size); new_str[i] = str[i], i++)
        ;
    delete [] str;
    return new_str;
}

8) Упражнение 7.10. Следующая функция хоть и вполне допустима, но менее полезна,
чем могла бы быть. Выявите и устраните ограничения.
bool test(string& s) { return s.empty(); } Написать main для аргументации своего решения

Ответ: если не сделать параметр string& s константным то мы не сможем передавать в эту функцию rvalue выражение.
поэтому функция должна выглядеть так: bool test(const string& s) { return s.empty(); }

#include <iostream>
#include <string>

bool test(std::string& s) { return s.empty(); }
bool test_fixed(const std::string& s) { return s.empty(); }

int main() {
    std::string str;
    std::cin >> str;
    std::cout << test(str) << std::endl;
    std::cout << test("abc") << std::endl;//выдаст ошибку
    std::cout << test_fixed(str) << std::endl;
    std::cout << test_fixed("abc");//все хорошо
    return 0;
}

9) Упражнение 7.11. Когда ссылочные параметры должны быть константными? 
Какие проблемы могут возникнуть, если параметр является обычной ссылкой, 
а какие — если он является константной ссылкой?

Ответ: если параметр является обычной ссылкой, то мы можем случайно изменить значение по этой ссылке на другое,
а если параметр является константной ссылкой, то если нам будет необходимо его изменить мы не сможем это сделать.

Материалы: 
1. Липпман, Стенли Б., Лажойе, Жози, Му, Барбара Э.
Язык программирования C++. Вводный курс, 4-е издание.: Пер.с англ. - М.: ООО "И.Д.Вильямс", 2007
	Глава 2. Переменные и базовые типы
		2.5 Ссылки, с.81-83
		Термины, с.99
	Глава 4. Массивы и указатели
		4.2 Знакомство с указателями
		4.2.3 Операции с указателями, с.145-146
	Глава 7. Функции
		7.2 Передача аргументов
		7.2.2 Ссылочные параметры, с.258-264

2. Александр Смаль, Михаил Кринкин
Программирование на языке C++
https://stepik.org/course/7
