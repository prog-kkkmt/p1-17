ЛЗ 6. Решение задач по теме "Ссылки
Выполнил студент группы П1-17 Карандашев Николай

1) Упражнение 2.24. Какие из следующих определений (если они есть) недопустимы? Почему? Как их исправить?
		(a) int ival = 1.01; - Скомпилируется, но сотая часть отрежется. Лучше использовать double
		(b) int &rvall = 1.01; - Ссылка может ссылаться только на переменную, а не на значение. не правильно
		(d) const int &rval3 = 1; - Ссылка может ссылаться только на переменную, а не на значение. не правильно

	 2) Упражнение 2.25. Какие из следующих присвоений (если они есть) являются недопустимыми
(с учетом предыдущих определений)? Если таковые есть, объясните, почему.
		(а)	rva12 = 3.14159;
		(b) rva12 = rva13;
		(с)	ival = rval3;
		(d) rval3 = ival; //невозможно
	3) Упражнение 2.26. В чем разница между определениями (а) и присвоениями (Ь)?
Какие из них (если есть) недопустимы?
		(a)	int ival = 0; - недопустимо потому что ссылку надо инициализировать обьектом


	4) Что отобразит на экране следующий код?
		int i, &ri = i; i = 5; ri = 10;
		std::cout << i << " " << ri << std::endl;
		
		Вывод - 10 10;

	5) Упражнение 4.15. Укажите принципиальные различия между указателями и ссылками.

		1.Указатель может быть переназначен любое количество раз, в то время как ссылка после привязки не может быть перемещена на другую ячейку памяти.
		2. Указатели могут указывать "в никуда" (быть равными NULL), в то время как ссылка всегда указывает на определенный объект.
		3. Мы не можем получить адрес ссылки, как можете это делать с указателями.
		4. Не существует арифметики ссылок, в то время как существует арифметика указателей.
		5. Нельзя объявить массив ссылок.	

	6) Упражнение 7.7. Объясните различие между параметрами в следующих двух объявлениях.
		void f(Т);
		void f(Т&);
		В одном случае передают значение переменной, а во втором ссылку.
То есть первая функция может изменять только глобальные переменная, а вторая может менять значение параметра.

	7) Упражнение 7.8. Приведите пример случая, когда параметр должен быть ссылочным.
Приведите пример случая, когда параметр не должен быть ссылочным.
параметр должен быть ссылочным если 
void swap(int &rx, int &ry) {
	int temp;
	temp = rx;
	rx = ry;
	ry = temp;
}
В другом случае параметр может быть не ссылочным
bool test(string s) { 
	return s.empty(); 
}
	8) Упражнение 7.10. Следующая функция хоть и вполне допустима, но менее полезна,
чем могла бы быть. Выявите и устраните ограничения.
bool test(string& s) { return s.empty(); } Написать main для аргументации своего решения

	#include <iostream>

	using namespace std;

	bool test_1(string& s) { return !s.empty(); }
	bool test(const string& s) { return !s.empty(); }

	int main(){
		string a;
		cin>>a;
		cout<<test_1("kfgn")<<endl;///не скомпилируется так как ссылка не может ссылаться на значение
		cout<<test_1(a)<<endl;///скомпилируется
		cout<<test("kfgn")<<endl;///скомпилируется const ссылка может ссылать(так же будет работать если из функции удалить &)
		cout<<test(a)<<endl;///скомпилируется
	}



9) Упражнение 7.11. Когда ссылочные параметры должны быть константными? 
Какие проблемы могут возникнуть, если параметр является обычной ссылкой, 
а какие — если он является константной ссылкой?

если в функцию необходимо передать большие объекты, которые не должны изменяться, то определение параметров именно как константных ссылок больше всего подходит для данной задачи.

если параметр является обычной ссылкой то при передлаче прямого значения возникает ошибка этапа компиляции 
Неконстантная ссылка может быть связана только с неконстантным объектом такого же типа

параметр переданный const ссылкой нельзя изменить
